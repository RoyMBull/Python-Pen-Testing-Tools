import socket
import paramiko
import os
import sys
import random 
import threading

os.system("clear")


""" TEST CODE FOR LATER WITH PARAMIKO 

    #This is going to be how we eventually call the main code to build he RSA crypto keys when we need to
    host_keys = paramiko.RSAKey.generate(bits=5260) 
    host_keys.write_private_key(filename=key, key=host_keys, password=None, format="PEM")
    print(keydata)

    https://gist.github.com/cschwede/3e2c025408ab4af531651098331cce45 //THis si a good exampel where we cann see solid code on how to make an ssh server applciation

    //What python is allowwing us to do is soemthing called semi constructors, which is if we redefine and name a function after one that is 
      inherited it will auto rn it like a consturctor with any calles we make to it, as well as any paramter cvalues that are checked to it

    //The server side function is being used in order to check if the the credentials refrenced from the main transport class object are correct for us to authenticate the end user to it

"""


#The ServerINterface class checks the transport channel of the main ssh session being started and follows authenticated credentials sent from the client side when it connects
#We can either choose to callthe function individually if we need it or ther serverr inteface is going to be called with the ufnctions when other functions need to tinteract with the main thread instance
class Server(paramiko.ServerInterface):
    
    #These are all constructor based functions that are set to auto run

    #This initial main constructor server to load th ebanner for the main ssh session, as well as check any authenication requests that come to the server
    #As well as checkig the legitimacy of any and all channels that established by the client to pipe in any commands for the remote session
    def __init__(self):
        #This is goint to run a separate thred in the program that will indicate the server interface vversion of paramiko that is at play
        self.event = threading.Event()

    #This is going to check if a channel can be opened with the respective client 
    #This function is also goign to sit here in case the client sends over some data so the server interface can chekc whether or not the main shell cna be established
    def check_channel_request(self, kind, chanid):
        if kind == 'session':
            #print("testing the chan") #This is just to test if the server is recieving shell channels from the main client side connection
            return paramiko.OPEN_SUCCEEDED #THese are getting sent along the mian popeline for the ssh protocol to the cleint side end to inddicate the authentication process
    	
    #THis is going to chekc the main pipeline of the credentiasl that were sent over by the client to autthenticate them to the ssh server
    def check_auth_password(self, username, password):
        if (username == "root") and (password == "toor"):
            #print("testing") #This is just to test if the is recieving authentication credentials from the main client side
            return paramiko.AUTH_SUCCESSFUL  

    #This is needed in order to 
    def check_channel_shell_request(self, channel, command):

        print("This is working correctly")      
        return True            



#Next we neeed to generate the main host keys for the session
#For now until we are able to utilzie the main paramiko.RSAKey class module we need to make a kkey using the ssh-keygen command in linux -> ssh-keygen -b 2450 -t RSA -m PEM (hit enter twice in order to avoid the key being encrypted)
""" KEY GENERATION PROCESS

    NOTE: WE MIGHT HAVE TO DEFIEN A CHANNEL FOR THE CLINET TO COMMUNICAE WITH FOR THE AUTHENTICATION PROCESS USING THE PARAMIKO.CHANNEL.CHANNEL() CLASS FUNCTION

* First we need to generae the key in order to defeine the main byte size
* THen we need to format it and convert it to pem
* Then we need to se the main passphrase for it
* THis is going to allow us to have a key automatically generate for it every time
"""

print("Generating New Key...")
host_key = paramiko.RSAKey.generate(bits=5260)
Session_Check = True
CommandShell_Check = True

#Next we need to have the main server import the key
#host_key = paramiko.RSAKey(filename='rsa.key') #THis is causing the bug for the program

#(filename='rsakey.key')

#Defien the main IP and port of the system for the ssh connection to listen onto
ip = ""
port = 1 #EACH TIME WE LOAD AND GENERATE A PUBLIC KEY OUR MAIN SYSTEM WILL LOAD AND RMEMBER IT ON THE CONFIGURATIONS FILE FOR THE ADDRESS AND PORT THE KEY IS STORED ON
#port = 20 #This is the mian default port for our program when the scrpt runs COMMENT THIS OUT FOR THE REAL EXPLOIT
address = (ip, port) #This is going to randomize th eport numbers so we don't have to worry about misconfigured ports being used when a session is terminated 

#Next setting up the sockets for the sessiion using both TCP connections as well as a setsockepts for it so that it can handle the SSH cleinnts 
#THIS SOCKET OBJECT CANNOT BE USED TO SEND DATA TO THE CLIENTS AS IT'S IN A LISTENING STATE ALREADY
sshserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sshserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sshserver.bind(address) 
sshserver.listen(10)

#Next we need to set up the socket to wait for incoming connections for the first layer of the session, which isthe socket session
while Session_Check: #I migth consider removing this 

    #The server is going to be put into a listening state to accept connections to the server
    print("Server in listening state on PORT => ", port)
    connection, client_addr = sshserver.accept() #USE THE CONNECTION ATRIBUTE FROMT HE SSHSERVER.ACCEPT() IN ORDER TO SEND DATA TO CLIENTS CONNECTED TOT HE SSH SERVER

    #We are going to set up a socket based option to give the end user the option to choose a route that executes key based encryption on top of passphrase ones

    #This is goning to upgrade the connection and tunnel it through the main ssh protocol so it can prompt the user for a passphrase 
    sshserversession = paramiko.Transport(connection) #The connection attribute already contanins the main IP and port the cleint is using to connect, so we transport them into the session with that

    #Next we need to define the main channel object to allow the ssh communication to occur, as well as redieve data commands and generate the channel ID for the clinet to connec to
    #They need to be on the same channel so that the cleint and the server can communicate with eachother
    serverchannel = paramiko.channel.Channel('c100')  #If this doens't worl then we are goint o pipe i tinot a vt100 type of terminal sessio so we can receive comands from teh client

    #Next we add in the main host keys for the connection that have been geneated for us. For as long as the server is running these will be the main keys that work overall
    sshserversession.add_server_key(host_key)

    #Next we define the main server interface object that will server to further handle and authenticate the user to the secure channel to pip in shell code to the target system
    server = Server()

    #Next we start up the main server which wilm authenticate the client end useers to the ssh server and other various functions that are needed for it
    #The authentication process is being handled by a separate thread by the class constructors so no need to worry about
    sshserversession.start_server(server=server)
    
    break

    #Once the authentication process is done, then we will sit the server in place to handle and take in shell code commands from the client side end
    #Once the main server is set up and has been inintialized one thread is waiting for commands, while the other is waiting and checking the channel in case credentials are bing sent
    #We need to program the first layer of the threads to ignroe anything that seem to be authenication if it's woreded after a credntial
    

    #If the client side which is  programeed using paramiko ocnenct to the mian server socket it is connecting and sending over connection handle data while at the same itme also sending over credentials which       
    #will cause the main server to authenticate like normal to the first thread while waiting for connecctions

    #After the cleint maages to authenticate to the server the shell session needs to be checked and generated throughout the mian transport ofthe server side session

#This loop is going to server to wait for ssh commands and then execute them  on the rmoete system (THE SHELL OPTION ISN'T WORKING AND THE PARAMIKO SERVER KEEPS REJECTING ANY AND ALL SHELL_EXEC REQUEST WE TRY TO MAEK TO THE SERVER FROM TEH CIENT SIDE)
while True:

    print("Waiting on client side datat to begin executing shell code commands on the server side end")
    sshclientdata = connection.recv(7000).decode('UTF-8') #We are going to set this to handle a total of 7000 bytpes to the ssh server application

    print(sshclientdata) #Thsi is going to print out th esshclient side data that is piped into the main trasnposrt of the session
    