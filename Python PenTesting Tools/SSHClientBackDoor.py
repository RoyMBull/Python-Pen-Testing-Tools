import socket
import paramiko
import os
import sys


""" DO NOW

    NOTE: IN PYTHONE WE CAN CALL CLASS MODUELS WITHOUT THE NEEDS OF AN OBJECT PLACEHOLDING THE ORIGNAL OBJECT

    * Get the SSH server up and runing on our end
    * We need to figure out how to get the program to chain multip;e commads using a logical based loop ton iterate it
    * We might have to do over how to configure a ssh server using a new set ocode in python3

    *Data to update to the mian chear sheet:

        * the channel sub class from the paramiko module (from paramiko.channel import Channel)
        * pramiko.RSAKey.generata() and paramiko.RSAKey.from_private_key() (the RSAKey sub class of the paramiko module)
        * invoke_shell() 
        * exec_command()
        * paramiko.ServerInterface module of the paramiko module 

        https://docs.paramiko.org/en/stable/api/transport.html
        https://docs.paramiko.org/en/stable/api/channel.html
        https://docs.paramiko.org/en/stable/api/server.html

        //THis will eventualy be a link that wil load up all the main types of terminal shell sessions that can be created with the SSH protocol

    #For the crypto keys we are gogin to use the ssh-keygen command in linux in order to gerate a file 


"""

# https://pyneng.readthedocs.io/en/latest/book/18_ssh_telnet/paramiko.html This is a good site to refence for the code
# https://stackoverflow.com/questions/22141637/paramiko-python-ssh-multiple-command-under-a-single-channel //The rules for the exc_command() are present ehre

# https://stackoverflow.com/questions/54612609/paramiko-not-a-valid-rsa-private-key-file#60000004 //THese 2 links helps you learn how to generate RSA keys in linux
# https://docs.oracle.com/en/cloud/cloud-at-customer/occ-get-started/generate-ssh-key-pair.html
# https://github.com/paramiko/paramiko/issues/2072

#Clear the console screen for startup 
os.system("clear") 

#Defines the mai target IP and port the cleint wishses to connect to 
ip = input("Target IP? =>   ")
port = int(input("Target Port? =>   "))
address = (ip, port)

#Sets the main credentials that the client needds to send over to authenticate for SSH
username = input("Username? =>   ")
passwd = input("Password? =>   ")
credentials = (username, passwd)

"""
#This is going to be used if we do have a priate key to import
private_key = "/home/kali/Desktop/rsa.pem"
pkey = paramiko.RSAKey.from_private_key_file(private_key) #This will cause the THE KEY NEEDS to be unencrypted for this to work (IT NEEDS TO BE EGENRAED WITHOUT A PASSPHRASE ON IT)
print(pkey)

if pkey: #If there is a key successfully generated then we print confirm to the screen and ask for input to proceed
    input("YOur key has been read please hit enter")
"""   


#First we are going to start defining the main SSHCleint for the session
sshclient = paramiko.SSHClient()

#Next thing to do is to begin setting up the main channel for paramiko, which will also set up our main secure channel that will tunnel over the main socket 
#WE NEED THIS IN ORDER TO RECIEVE DATA AS THE CLEINT FROM THE MAIN SSH SERVER FOR THE SECURE CHANNELS 
#THis is also used in order to create a secure chann
sshclientchannel = paramiko.channel.Channel('c100') #This sets up the main channel name for the connecitonn with the SSH clint and will set the ID of the secure channel

#This is going to allow us to extract any and all host keys that the main SSH server will generate  for us
# sshclient.load_system_host_keys() Only use this when connecting to an unkown ssh server that is being connected to multiple times

#THis is going to add the missing host key policy for in case we are missing any host keys asosicated with the session on the system
sshclient.set_missing_host_key_policy(paramiko.AutoAddPolicy)

#We need to split the logic for this so that it can tell if we are suing either a key based connection, or a no key based connection 
#Last thing to do is to connect the target tothe main ssh server socket so we can start the reasl session for it
tcpconnection = str(sshclient.connect(ip, port, username, passwd)) #  ADD THE PARAMATER "pkey" back in when ready to test again   Remove the pkey along iwth the from_private key() whne using ths without key based authentication
#This will also auto generate a session for the ssh connection on our behlaf as well until it's terminate
sshclient.get_transport().open_session() #This is oging to open the main session to allow us to pipe commands to the server whoole also recieivng session detils from the server side that's piped ito the main server to cleint side responsese and return values


"""
#The program will check if the client is conencted, else it will terminate the main connection and close it out
if tcpconnection == "None": #We need to set this back to none in order to test if the client is receiving data successfulyl via the channel object for it 

    #The client will be told it's awating for acknowledgement by the server for a connection approval message 
    print("Connection to ", ip, ":", port, " => established... waiting for acknowledgement from the server....")
    print("")

    ping = "this is a ping test".encode('UTF-8')
    sshclient.send(ping)
    input("Waitig to see if the main server reciees the data")
    connectionresponse = sshclientchannel.recv(7000) #This is how SSH is abl eto recieve data on the client side end and this also opens up an encryptted chanel for a secure communication using paramiko
    print(connectionresponse)
    print("")
        
    input("Hit Enter  ")
"""
#This allows us to send data to the SSH server, as well as execute direct commands to the main system is going to invoke the main shell for the exploit THIS WILL ALOS BE THE MAIN OBJECT WE USE TO SEND DATA TO THE SERVER
#THIS CAN ONLY BE DONE AFTER WE CONNECT TO THE MAIN
#We can also use this in order to c

#This is going to begin taking in shell code arguments to the main session opened with the SSH server
while True:

    os.system("clear")
    
    print("Enter in a command now. Hit enter at the end of the output to enter in the next line of command")
    sshcommand = input("")
    if sshcommand == "exit": #If we send over the command "exit" to the paramte it will close out the main while loop and bring us to the end ofthe code where it will close out the mian shel connection
        break

    #This is going to launch our main shell for the ssh session that will allow commands to be piped and passed to the main SSH server over a secure communication pipeline
    shell = sshclient.invoke_shell() #The main problem now is that our main session keeps terminating and closnig YOu can also define the type of shell you will be using her as well
    #The command will be sent to the exec_command() function using the mian socket from pramiko
    stdin, stdout, stderr = sshclientchannel.exec_command(sshcommand) #YOU CAN ONLY SEND ONE OCMMAND AT A TIME, AND EACH TIME YOU DO, THE CHANNEL THAT WAS OPENED IS Closed

    #The exit status of the commadn execution will be recorded nad the lines of the command will be printed back to us so we can see the main results
    stdout.channel.recv_exit_status()
    lines = stdout.readlines()
    for line in lines:
        print (line)
    input("")

sshclient.close()

#This is going to start the main loop argument where it will 


""" The data has definetly been sent  WE CAN REMOVE THIS LATER
data = "ping test".encode('UTF-8') 
if shell.send(data):
    print("Data has been sent to the main server")
"""
