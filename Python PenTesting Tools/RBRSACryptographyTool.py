from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.fernet import Fernet
import base64

import os 
import sys


def RSAEncryptionTool(Mode):
    
    if Mode == 1:
        print("Generating Asymetric RSA Encryption!.....")
        print("Making the Public and Private Keys now")

        # generate private/public key pair
        private_key = rsa.generate_private_key(backend=default_backend(), public_exponent=65537, \
            key_size=2048)
        

        # get public key in OpenSSH format
        public_key = private_key.public_key()

        #Store the keys 
        PrivateKeyData = private_key.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption())
        PublicKeyData= public_key.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo)

        #Write the keys to said Files
        StorePrivateKey = open("PrivateKey.txt", 'wb')
        StorePubliceKey = open("PublicKey.txt", 'wb')
        StorePrivateKey.write(PrivateKeyData)
        StorePubliceKey.write(PublicKeyData)
        StorePrivateKey.close()
        StorePubliceKey.close()

        print("KEYS GENERATED!!!! STORE PROPERLY!!!!")
        C = input("Hit Enter")
    #THIS CODE IS STILL IN TESTING!!!!!
    if Mode == 2:

       
        print("Generating Symetric RSA Encryption!.....")
        print("Making the Private Key now")

        # generate private/public key pair
        private_key = rsa.generate_private_key(backend=default_backend(), public_exponent=65537, \
            key_size=2048)

        #Store the keys 
        PrivateKeyData = private_key.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption())

        #Write the keys to said Files
        StorePrivateKey = open("PrivateKey.txt", 'wb')
        StorePrivateKey.write(PrivateKeyData)
        StorePrivateKey.close()

        print("KEYS GENERATED!!!! STORE PROPERLY!!!!")

        Data = input("Enter your message: => ")
        message = bytes(Data, 'utf-8')

        print(message)

        encrypted = private_key.encrypt(
            message,
            padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
            )
        )

        print(encrypted)

        #MUST BE WRITTEN IN BINARY!!!!!! OTHERWISE THE MESSAGE WILL NOT BE 
        #THE SIZE OF THE PRIVATE KEY WHEN TIME TO DECRYPT
        print("MESSAGE GENERATED!!!! STORE PROPERLY")
        EncryptMssg = open("PRIVATEMessage.txt", 'wb') 
        EncryptMssg.write(encrypted)
        EncryptMssg.close()

        #This to check the length of the encrypted message, so that it is 256 bytes
        #os.system("cls")
        #Test = str(encrypted)
        #print("LENGHT OF THE ORIGINAL ENCRYPTED MESSAGE", len(encrypted))
        #print("LENGHT OF THE MESSAGE CONVERTED", len(Test))

        original_message = private_key.decrypt(
            encrypted,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        print(original_message)

        print("Encryption COMPLETE")

    if Mode == 3:
        
        Msg = input("Enter your message to encrypt: => ")
        ConvertMsg = bytes(Msg, 'utf-8')

        print("")

        PublicKey = input("Provide the name of the Public Key to Encrypt: => ")
        PubKey = open(PublicKey, 'rb')
        StoreKey = PubKey.read()
        PubKey.close()

        LoadPublicKey = serialization.load_pem_public_key(
            StoreKey,
            backend=default_backend()
        )

        EncryptMsg = LoadPublicKey.encrypt(
            ConvertMsg,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        print("MESSAGE ENCRYPTED!!!!")
        print("MESSAGE: => ", EncryptMsg)

        StoreMsg = open("PrivateMsg.txt", 'wb')
        StoreMsg.write(EncryptMsg)
        StoreMsg.close()

        Con = input("Hit Enter")


    if Mode == 5:
        
        print("Provide the name of the file containing the encrypted contents")
        #Provide the message corresponding to the key
        Msg = input("Enter now: => ")
        OpnMsg = open(Msg, 'rb')
        ReadMsg = OpnMsg.read()
        OpnMsg.close()

        print("Provide the name of the Private Key to Decrypt the Message")
        
        #Reads and stores the set private key in a variable
        Key = input("Enter now: => ")
        UsePrivateKey = open(Key, 'rb')
        ReadPrivateKey = UsePrivateKey.read()
        UsePrivateKey.close()

        print("")
        
        #Next we import/load the private key and convert it to base64 format (Convert to bytes first if not done so)
        LoadPrivateKey = serialization.load_pem_private_key(
            ReadPrivateKey,
            password=None,
            backend=default_backend()
        )

        DecryptMsg = LoadPrivateKey.decrypt(
            ReadMsg,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        print("DECRYPTION COMPLETE!!!!")
        print("MESSAGE: => ", DecryptMsg)
        print("")
        Enter = input("Hit Enter")
        #Decrypt the message
        #DecryptMsg = LoadKey.decrypt(ReadMsg)

        #if DecryptMsg:
            #print("Decryption Success!!!!")
            #print("Message: => ", DecryptMsg)

    if Mode == 7:
        
        FileNme = input("Enter your file to encrypt: => ")
        ReadFl = open(FileNme, 'rb')
        RecordFile = ReadFl.read()
        ReadFl.close()

        print("")

        PublicKey = input("Provide the name of the Public Key to Encrypt: => ")
        PubKey = open(PublicKey, 'rb')
        StoreKey = PubKey.read()
        PubKey.close()

        LoadPublicKey = serialization.load_pem_public_key(
            StoreKey,
            backend=default_backend()
        )

        EncryptMsg = LoadPublicKey.encrypt(
            RecordFile,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        print("FILE ENCRYPTED!!!!")
        print("FILE: => ", EncryptMsg)

        StoreMsg = open("PrivateFile.txt", 'wb')
        StoreMsg.write(EncryptMsg)
        StoreMsg.close()

        Con = input("Hit Enter")







while True:

    print("RSA KEY GEN/DECRYPT TOOL")
    print("")
    print("Commands:") 
    print("Generate Asymetric RSA Keys?: => 1 ")
    #print("Symetric RSA Encryption: => 2 ")
    print("Create a msg using existing Asymetric Keys?: => 3")
    #print("Create a msg using existing Symetric Keys?: => 4")
    print("RSA Decryption VIA Asymetric: => 5")
    #print("RSA Decryption VIA Symetric: => 6")
    print("Encrypt a file using existing Asymetric Keys: => 7")
    #print("Encrypt a file using existing Symetric Keys: => 8")
    print("")

    Option = int(input("Select your option now: => "))

    RSAEncryptionTool(Option)
    os.system("cls")